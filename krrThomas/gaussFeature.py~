


def calculateFeatureVectorGaussian(self, coordinateSet, i):
    ''' Calculates the feature vector based on Gaussian approach. Initially just a 2D vector
    with one radial and one angular component. Need to figure out a way to decide on parameters.
    These are just manually set at the moment. Can implement parameters way better.'''
        
    featureVector = np.zeros(6)   # Set size of feature vector here
    dataSize = len(coordinateSet)
        
    eta, Rs = 0.002, 0                # Guess some parameters for radial part
    x0, y0 = coordinateSet[i][:2]
    for s in range(3):
        if s == 1:
            eta, Rs = 0.001, 0
        if s == 2:
            eta, Rs = 0.001, 2
        f1 = 0
        for j in range(dataSize):     # Calculate radial part
            if j == i:
                continue
            x, y = coordinateSet[j][:2]
            Rij = np.sqrt((x0 - x)**2 + (y0 - y)**2)
            if Rij <= self.Rc:
                f1 += np.exp(- eta * (Rij - Rs)**2 / self.Rc**2) * self.cutOffFunction(Rij)
                #f1 = Rij  # Test for two atoms
        featureVector[s] = f1
    xi, lamb, eta = 2, 1, 0.005    # Guess some parameters for angular part
    f2 = 0                         # Calculate angular part
    for p in range(3):
        if p == 1:
            xi, lamb, eta = 0, -1, 0.005
        if p == 2:
            xi, lamb, eta = 0, 1, 0.005
        for j in range(dataSize):
            if j == i:
                continue
            for k in range(j, dataSize):
                if k == j or k == i:
                    continue
                # Calculate the distances between atoms
                RijVec = coordinateSet[j][:2] - coordinateSet[i][:2]
                Rij = np.linalg.norm(RijVec)

                RikVec = coordinateSet[k][:2] - coordinateSet[i][:2]
                Rik = np.linalg.norm(RikVec)

                RjkVec = coordinateSet[k][:2] - coordinateSet[j][:2]
                Rjk = np.linalg.norm(RjkVec)

                f2 += (1 + lamb * np.dot(RijVec, RikVec) / (Rij * Rik))**xi * np.exp(- eta * (Rij * Rij + Rik * Rik + Rjk * Rjk) / self.Rc**2) * self.cutOffFunction(Rij) * self.cutOffFunction(Rik) * self.cutOffFunction(Rjk)
        f2 *= 2**(1 - xi)
        featureVector[s + p + 1] = f2
    # Set and return feature vector
    return featureVector

class gaussFeatures():
    def __init__(self, X=None, eta=4, Xi=2, cutoffRadius=6, lamb=[-1,1], **parameters):
        """
        Parameters:
        Radial part:
        """
        self.X = X
        self.cutoffRadius = cutoffRadius
        self.lamb=lamb
        self.Xi = Xi
        self.eta = eta
        
