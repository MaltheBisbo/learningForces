""" Methods for generating new random starting candidates. """
from random import shuffle
import numpy as np
from ase import Atoms
from ase.ga.utilities import get_mic_distance
from math import *
from copy import deepcopy
from time import sleep
from ase.constraints import FixedLine, ImitateP4symm, ImitateZ
#from constraintP4 import ImitateP4symm, ImitateZ
#from builtins import *  # to get range in python 2.7

def random_pos(box):
    """ Returns a random position within the box
         described by the input box. """
    p0 = box[0]
    vspan = box[1]
    r = np.random.random((1, len(vspan)))
    pos = p0.copy()
    for i in range(len(vspan)):
        pos += vspan[i] * r[0, i]
    return pos

def random_pos_elliptic(box):
    """ Returns a random position within the elliptic 
        cylinder described by the input vectors a,b,c 
        and the x,y-coordinates for the center. """
    p0 = box[0]
    vspan = box[1]
    center = box[2]
    a = vspan[0][0].copy()
    b = vspan[1][1].copy()
    tmp_vspan = deepcopy(vspan)
    tmp_vspan[0][0] += tmp_vspan[0][0] * 2
    tmp_vspan[1][1] += tmp_vspan[1][1] * 2
    F1 = center.copy()
    F2 = center.copy()
    F1[0] += sqrt(a ** 2 - b ** 2) 
    F2[0] += -sqrt(a ** 2 - b ** 2) 
    approved = False
    while approved == False:
        r = np.random.random((1, len(vspan)))
        pos = p0.copy()
        for i in range(len(vspan)):
            pos += tmp_vspan[i] * r[0, i]
        pos += np.array((center[0], center[1], 0)) - np.array((a, b, 0))
        PF1 = np.linalg.norm(F1 - (pos[0], pos[1]))
        PF2 = np.linalg.norm(F2 - (pos[0], pos[1]))
        if PF1 + PF2 <= 2 * a:
            approved = True
    return pos



class StartGenerator(object):

    """ Class used to generate random starting candidates.
        The candidates are generated by iteratively adding in
        one atom at a time within the box described.

        Parameters:

        slab: The atoms object describing the super cell to
        optimize within.
        atom_numbers: A list of the atomic numbers that needs
        to be optimized.
        closed_allowed_distances: A dictionary describing how
        close two atoms can be.
        box_to_place_in: The box atoms are placed within. 
        if elliptic is False the standard box for atoms is used:
           The format is [p0, [v1, v2, v3]] with positions being 
           generated as p0 + r1 * v1 + r2 * v2 + r3 + v3
        if elliptic is True the box used to contain the atom distribution:
           The format is [p0, [a, b, z], center] with positions being
           generated and limited to only be inside a elliptic box 
           with p0 and center describing the center and a,b,z the normal
           length, width and height.
        cluster: The attribute that describes whether the atoms 
        can or can't be placed far apart.
    """
    def __init__(self, slab, atom_numbers,
                 closest_allowed_distances, box_to_place_in, elliptic=False, cluster=True):
        self.slab = slab
        self.atom_numbers = atom_numbers
        self.blmin = closest_allowed_distances
        self.box = box_to_place_in
        self.elliptic = elliptic
        self.cluster = cluster
        self.descriptor = 'StartGenerator'
        
    def get_new_individual(self, parents=None):
        a = self.get_new_candidate()

        try:
            a.info['key_value_pairs']['origin'] = 'StartGenerator'
        except:
            a.info['key_value_pairs'] = {'origin': 'StartGenerator'}
            
        return a, 'mutation: startGenerator'
        
    def get_new_candidate(self,maxlength=2.):
        """ Returns a new candidate. """
        N = len(self.atom_numbers)
        cell = self.slab.get_cell()
        pbc = self.slab.get_pbc()

        Nslab = len(self.slab)
        pos_slab = self.slab.get_positions()
        num_slab = self.slab.get_atomic_numbers()
        

        # The ordering is shuffled so different atom
        # types are added in random order.
        order = [i for i in range(N)]  # range(N)
        shuffle(order)
        num = [i for i in range(N)]  # range(N)
        for i in range(N):
            num[i] = self.atom_numbers[order[i]]
        blmin = self.blmin

        # Runs until we have found a valid candidate.
        while True:
            pos = np.zeros((N, 3))
            # Make each new position one at a time.
            for i in range(N):
                pos_found = False
                pi = None
                for _ in range(1000):
                    if self.elliptic == True:
                        pi = random_pos_elliptic(self.box)
                    else:
                        pi = random_pos(self.box)

                    too_close = False
                    for k in range(Nslab):
                        d = get_mic_distance(pi, pos_slab[k], cell, pbc)
                        bij_min = blmin[(num[i], num_slab[k])]
                        if d < bij_min:
                            too_close = True
                            break
                    if too_close:
                        continue
                        
                    if i == 0:
                        pos_found = True
                        break
                    isolated = self.cluster

                    
                    
                    #bij_min_array = np.array([blmin[num(i), num(j)] for j in range(i)])
                    #bij_max_array = bij_min_array * maxlength
                    for j in range(i):
                        d = get_mic_distance(pi, pos[j], cell, pbc)
                        bij_min = blmin[(num[i], num[j])]
                        bij_max = bij_min * maxlength
                        if d < bij_min:
                            too_close = True
                            break
                        if d < bij_max:
                            isolated = False
                    # A new atom must be near something already there,
                    # but not too close.
                    if not isolated and not too_close:
                        pos_found = True
                        break
                if pos_found:
                    pos[i] = pi
                else:
                    break
            if pos_found:
                break

            
            
        # Put everything back in the original order.
        pos_ordered = np.zeros((N, 3))
        for i in range(N):
            pos_ordered[order[i]] = pos[i]
        pos = pos_ordered
        top = Atoms(self.atom_numbers, positions=pos, pbc=pbc, cell=cell)

        return self.slab + top


class StartGenerator_p4sym(object):

    """ Class used to generate random starting candidates.
        The candidates are generated by iteratively adding in
        one atom at a time within the box described.

        Parameters:

        slab: The atoms object describing the super cell to
        optimize within.
        atom_numbers: A list of the atomic numbers that needs
        to be optimized.
        closed_allowed_distances: A dictionary describing how
        close two atoms can be.
        box_to_place_in: The box atoms are placed within. 
        if elliptic is False the standard box for atoms is used:
           The format is [p0, [v1, v2, v3]] with positions being 
           generated as p0 + r1 * v1 + r2 * v2 + r3 + v3
        if elliptic is True the box used to contain the atom distribution:
           The format is [p0, [a, b, z], center] with positions being
           generated and limited to only be inside a elliptic box 
           with p0 and center describing the center and a,b,z the normal
           length, width and height.
        cluster: The attribute that describes whether the atoms 
        can or can't be placed far apart.
    """
    def __init__(self, slab, atom_numbers,
                 closest_allowed_distances, box_to_place_in,
                 wickoff={}, cluster=True):
        self.slab = slab
        self.atom_numbers = atom_numbers
        self.blmin = closest_allowed_distances
        self.box = box_to_place_in
        self.wickoff = wickoff
        self.cluster = cluster
        self.descriptor = 'StartGenerator'

        self.center_xy = np.array([self.box[1][0][0], self.box[1][1][1]])

        # Atomic numbers for the wickoff atoms
        Nwickoff = 0
        for site in ['a', 'b', 'c']:
            if site in self.wickoff:
                if site == 'c':
                    Nwickoff += 2*len(self.wickoff[site])
                else:
                    Nwickoff += len(self.wickoff[site])
        
        # relevant atoms to rattle (all Wickoff + a fourth of the other mobile atoms)
        #Nwickoff = np.sum(np.array([len(x) for x in self.wickoff.values()]))
        index_wickoff = np.arange(len(slab), len(slab) + Nwickoff).astype(int)
        index_base = np.arange(len(slab) + Nwickoff,len(slab) + Nwickoff + 4*len(atom_numbers), 4).astype(int)
        self.index2mutate = np.append(index_wickoff, index_base)
        
    def get_new_individual(self, parents=None):
        a = self.get_new_candidate()

        try:
            a.info['key_value_pairs']['origin'] = 'StartGenerator'
        except:
            a.info['key_value_pairs'] = {'origin': 'StartGenerator'}
            
        return a, 'mutation: startGenerator'
        
    def get_new_candidate(self,maxlength=2.):
        """ Returns a new candidate. """
        N = len(self.atom_numbers)
        cell = self.slab.get_cell()
        pbc = self.slab.get_pbc()

        wickoff = self.get_wickoff()
        slab = self.slab + wickoff
        
        Nslab = len(slab)
        pos_slab = slab.get_positions()
        num_slab = slab.get_atomic_numbers()
        

        # The ordering is shuffled so different atom
        # types are added in random order.
        order = [i for i in range(N)]  # range(N)
        shuffle(order)
        num = [self.atom_numbers[order[i]] for i in range(N)]
        blmin = self.blmin

        # Runs until we have found a valid candidate.
        while True:
            pos = np.zeros((4*N, 3))
            # Make each new position one at a time.
            for i in range(N):
                pos_found = False
                posi = None
                for _ in range(1000):
                    posi_p4 = np.zeros((4,3))
                    posi_p4[0] = random_pos(self.box)
                    for i_p4, theta in enumerate([np.pi/2, np.pi, 3/2*np.pi]):
                        posi_p4[i_p4+1] = self.get_p4pos(posi_p4[0], theta)

                    too_close = False
                    # Check if p4 atoms are too close:
                    # - Enough to test one with the rest
                    for p in posi_p4[1:]:
                        d = get_mic_distance(posi_p4[0], p, cell, pbc)
                        bij_min = blmin[(num[i], num[i])]
                        if d < bij_min:
                            too_close = True
                            break
                    if too_close:
                        continue

                    isolated = self.cluster
                    # Check distance to slab
                    # - Enough to test one of the four
                    for k in range(Nslab):
                        d = get_mic_distance(posi_p4[0], pos_slab[k], cell, pbc)
                        bij_min = blmin[(num[i], num_slab[k])]
                        bij_max = bij_min * maxlength
                        if d < bij_min:
                            too_close = True
                            break
                        if d < bij_max:
                            isolated = False
                    if too_close:
                        continue
                        
                    if i == 0:
                        pos_found = True
                        break
                    

                    # Check distance to all previously placed
                    # - Enough to test for one of the four
                    for j in range(4*i):
                        d = get_mic_distance(posi_p4[0], pos[j], cell, pbc)
                        bij_min = blmin[(num[i], num[j//4])]
                        bij_max = bij_min * maxlength
                        if d < bij_min:
                            too_close = True
                            break
                        if d < bij_max:
                            isolated = False
                    # A new atom must be near something already there,
                    # but not too close.
                    if not isolated and not too_close:
                        pos_found = True
                        break
                if pos_found:
                    pos[4*i:4*(i+1)] = posi_p4
                else:
                    break
            if pos_found:
                break

            
            
        # Put everything back in the original order.
        pos_ordered = np.zeros((4*N, 3))
        for i in range(N):
            pos_ordered[4*order[i]:4*(order[i]+1)] = pos[4*i:4*(i+1)]
        pos = pos_ordered
        atom_numbers_p4 = np.repeat(self.atom_numbers, 4)
        top = Atoms(atom_numbers_p4, positions=pos, pbc=pbc, cell=cell)

        # Apply constraints to enforce p4-symmetry
        Nslab = len(self.slab)
        Nwickoff = len(wickoff)
        Nslab_wick = Nslab + Nwickoff
        Nadd_nonWick = 4*N
        structure = slab + top
        fixLine = [FixedLine(x, (0, 0, 1)) for x in range(Nslab, Nslab_wick)]
        fixP4_1 = [ImitateP4symm(i+1, i, self.center_xy, theta=np.pi/2) for i in range(Nslab_wick, Nslab_wick+Nadd_nonWick, 4)]
        fixP4_2 = [ImitateP4symm(i+2, i, self.center_xy, theta=np.pi) for i in range(Nslab_wick, Nslab_wick+Nadd_nonWick, 4)]
        fixP4_3 = [ImitateP4symm(i+3, i, self.center_xy, theta=3/2*np.pi) for i in range(Nslab_wick, Nslab_wick+Nadd_nonWick, 4)]
        Nwickoff_ab = np.sum(np.array([len(self.wickoff[site]) for site in ['a', 'b'] if site in self.wickoff])).astype(int)
        Nwickoff_c = int((Nwickoff-Nwickoff_ab)/2)
        print(Nwickoff_c)
        print([(i+Nwickoff_c, i) for i in range(Nslab + Nwickoff_ab, Nslab + Nwickoff_ab + Nwickoff_c)])
        fix_wick_c = [ImitateZ(i+Nwickoff_c, i) for i in range(Nslab + Nwickoff_ab, Nslab + Nwickoff_ab + Nwickoff_c)]
        
        constraints = self.slab.constraints + fixLine + fixP4_1 + fixP4_2 + fixP4_3 + fix_wick_c
        slab.set_constraint(constraints)
        
        return slab + top

    def get_wickoff(self, maxlength=2.):
        cell = self.slab.get_cell()
        pbc = self.slab.get_pbc()

        Nslab = len(self.slab)
        pos_slab = self.slab.get_positions()
        num_slab = self.slab.get_atomic_numbers()
        blmin = self.blmin

        d = cell[1,1]
        wickoff_xy_pos= {'a': [np.array([0,0])],
                         'b': [np.array([d/2,d/2])],
                         'c': [np.array([d/2,0]), np.array([0,d/2])]}
        
        # Atomic numbers for the wickoff atoms
        num_wickoff = []
        for site in ['a', 'b', 'c']:
            if site in self.wickoff:
                for pos_xy in wickoff_xy_pos[site]:
                    num_wickoff += self.wickoff[site]
        Nwickoff = len(num_wickoff)
        
        # get allowed z-range
        z0 = self.box[0][2]
        dz = self.box[1][2][2]

        
        n_placed = 0
        pos_wickoff = np.zeros((Nwickoff, 3))
        for site in ['a', 'b', 'c']:
            if site in self.wickoff:
                for num_i in self.wickoff[site]:
                    pos_xy_i  = wickoff_xy_pos[site][0]
                    for i in range(100):
                        z_i = z0 + dz*np.random.rand()
                        pos_i = np.append(pos_xy_i, z_i)
                        
                        too_close = False
                        isolated = self.cluster
                        # distance check distance to wickoff
                        for k in range(n_placed):
                            d = get_mic_distance(pos_i, pos_wickoff[k], cell, pbc)
                            bij_min = blmin[(num_i, num_wickoff[k])]
                            bij_max = bij_min * maxlength
                            if d < bij_min:
                                too_close = True
                                break
                            if d < bij_max:
                                isolated = False
                        if too_close:
                            continue

                        # distance check distance to slab
                        for k in range(Nslab):
                            d = get_mic_distance(pos_i, pos_slab[k], cell, pbc)
                            bij_min = blmin[(num_i, num_slab[k])]
                            bij_max = bij_min * maxlength
                            if d < bij_min:
                                too_close = True
                                break
                            if d < bij_max:
                                isolated = False
                        if too_close:
                            continue
                        if not isolated and not too_close:
                            pos_found = True
                            break
                    if pos_found:
                        pos_wickoff[n_placed] = pos_i
                        n_placed += 1

        if 'c' in self.wickoff:
            Nc = len(self.wickoff['c'])
            pos_wickoff[-Nc:, :2] = wickoff_xy_pos['c'][1].reshape((1,2))
            pos_wickoff[-Nc:, 2] = pos_wickoff[-2*Nc:-Nc, 2]
            
        wickoff = Atoms(num_wickoff, positions=pos_wickoff, pbc=pbc, cell=cell)
        return wickoff

    def get_p4pos(self, pos, theta):
        pos_rot = pos.copy()
        c, s = np.cos(theta), np.sin(theta)
        R = np.array(((c,-s), (s, c)))
        pos_xy = pos[:2] - self.center_xy

        pos_xy_rot = pos_xy @ R
        pos_xy_rot += self.center_xy

        pos_rot[:2] = pos_xy_rot
        return pos_rot
